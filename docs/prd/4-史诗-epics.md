# **4\. 史诗 (Epics)**

## **Epic 1: 核心路由与可靠投递**

**目标**: 构建通信系统的基础骨架，实现服务注册发现、两种核心路由模式，并完成“精确一次投递”的核心逻辑。

* **故事 1.1: 项目初始化与工程实践框架搭建**
  * **As a** 开发人员, **I want** 一个使用现代化工具、自动化质量检查和容器化环境初始化的新项目, **so that** 所有未来的开发都能遵循已确立的高质量工程实践。
  * **验收标准**:
    1. 项目使用 uv 和 pyproject.toml 管理依赖。
    2. Black, Ruff, Mypy 已配置并集成到pre-commit hook。
    3. 提供 Dockerfile 和 docker-compose.yaml 用于本地开发。
    4. 初始源代码目录遵循分层结构（domain, application, infrastructure）。
* **故事 1.2: 服务实例的基础注册与发现**
  * **As a** 服务实例, **I want** 能够向中央路由组件注册我的服务名和实例ID, **so that** 系统能够知道我的存在。
  * **验收标准**:
    1. 服务实例启动时能成功注册信息。
    2. 中央组件能存储和管理在线服务实例信息。
    3. 可通过管理接口查询已注册的服务列表。
* **故事 1.3: 实现服务组的轮询路由**
  * **As a** 调用方, **I want** 将请求发送到一个服务“名称”，并让系统自动将它路由给该服务组中一个可用的实例, **so that** 我可以实现对无状态服务的请求负载均衡。
  * **验收标准**:
    1. 发送到服务名的请求被投递到其中一个实例。
    2. 连续请求被分发到不同实例。
    3. 掉线实例会自动从路由池中移除。
* **故事 1.4: 实现基于资源的精确目标路由**
  * **As a** 调用方, **I want** 将一个请求发送给一个特定的“资源”, **so that** 系统能将该请求精确地投递到唯一一个正在处理该资源的实例上。
  * **验收标准**:
    1. 服务实例能注册自己正在处理一个或多个“资源ID”。
    2. 一个“资源ID”在同一时间只能被一个实例注册。
    3. 包含“资源ID”的请求被精确路由到对应的实例。
    4. 若请求的“资源ID”无实例处理，则返回明确错误。
* **故事 1.5: 构建“精确一次投递”的消息处理机制**
  * **As a** 通信系统, **I want** 实现一套结合了消息去重和应答确认的机制, **so that** 我能提供“精确一次”的投递保证。
  * **验收标准**:
    1. 发出的每条请求消息都有全局唯一ID。
    2. 接收方在成功处理业务后必须发送ACK。
    3. 系统在未收到ACK时会进行重试。
    4. 接收方必须是幂等的，能根据消息ID安全地忽略重复消息。

## **Epic 2: 高可用与故障转移**

**目标**: 在核心路由的基础上，增加主/备实例的健康检查、状态同步和自动故障转移机制，实现客户端的无感切换。

* **故事 2.1: 实现服务实例的心跳与健康检查**
  * **As a** 中央路由组件, **I want** 接收所有服务实例的周期性心跳, **so that** 我能准确地发现故障实例。
  * **验收标准**:
    1. 服务实例自动定期发送心跳。
    2. 中央组件根据心跳超时将实例标记为“不健康”。
    3. “不健康”的实例会从路由池中移除。
    4. “主用”实例不健康时触发故障转移。
* **故事 2.2: 支持主/备模式的服务注册**
  * **As a** 服务实例, **I want** 在注册处理特定资源时，能够声明自己的角色是“主用”还是“备用”, **so that** 系统可以建立明确的主备关系。
  * **验收标准**:
    1. 注册接口增加role参数(active/standby)。
    2. 同一资源只能有一个active实例。
    3. 重复注册active角色会被拒绝。
    4. 管理接口能展示主备关系。
* **故事 2.3: 实现自动的主/备切换逻辑**
  * **As a** 中央路由组件, **I want** 在监测到“主用”实例故障后，自动提升一个“备用”实例为新的“主用”, **so that** 服务可以尽快恢复。
  * **验收标准**:
    1. active实例不健康时自动触发故障转移。
    2. 系统从健康的standby实例中选择一个提升为active。
    3. 新的active实例立刻开始接收请求。
    4. 故障转移事件被详细记录在日志中。

## **Epic 3: 可观测性、可管理性与性能验证**

**目标**: 实现结构化日志、性能指标的暴露和管理接口。同时，构建并运行性能测试，验证系统是否满足所有目标。

* **故事 3.1: 集成并实现统一的结构化日志**
  * **As a** 开发/运维人员, **I want** 系统中所有组件都能输出统一的、结构化的（JSON格式）日志, **so that** 我可以方便地进行日志查询和故障排查。
  * **验收标准**:
    1. 集成日志库并配置JSON输出。
    2. 一次请求-响应生命周期的所有日志都包含同一个Trace ID。
    3. 所有关键事件都被记录。
* **故事 3.2: 暴露核心系统性能指标**
  * **As a** 运维人员, **I want** 系统能够通过一个标准的HTTP端点（例如 /metrics）暴露核心性能指标, **so that** 我可以实现对系统健康状况的实时监控。
  * **验收标准**:
    1. 中央路由组件提供 /metrics 端点。
    2. 至少暴露：在线实例数、队列深度、处理延迟、消息总量等指标。
    3. 指标能被Prometheus等工具采集。
* **故事 3.3: 开发基础的管理命令行工具 (CLI)**
  * **As a** 运维人员, **I want** 一个简单的命令行工具来与系统进行交互, **so that** 我可以执行实时的查询和基本管理操作。
  * **验收标准**:
    1. 提供 ipc-cli 脚本。
    2. ipc-cli list-services: 列出所有服务及其状态。
    3. ipc-cli show-route \<resource\_id\>: 查询特定资源的路由。
    4. ipc-cli disconnect \<instance\_id\>: 剔除某个实例。
* **故事 3.4: 构建并执行性能基准测试**
  * **As a** 开发人员, **I want** 一套自动化的性能测试脚本, **so that** 我可以验证系统原型是否达到了预设的性能和可靠性目标。
  * **验收标准**:
    1. 创建性能测试脚本，模拟真实负载。
    2. 测试能覆盖两种路由模式。
    3. 测试报告包含P99延迟和平均吞吐量。
    4. 验证测试结果是否达标（**吞吐量 \> 200 TPM, P99延迟 \< 5ms**）。
    5. 验证测试期间消息丢失率为 **0%**。
