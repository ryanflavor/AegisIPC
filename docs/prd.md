# **AegisIPC 分布式交易系统IPC原型 \- 产品需求文档 (PRD)**

## **1\. 目标与背景上下文**

### **目标**

* 验证一个可靠、高性能、多对多、且支持“精确一次投递”的IPC架构方案，为未来正式的交易系统开发奠定技术基础。
* 产出一个可被其他开发者轻松集成的Python客户端库（SDK），证明该方案的可用性和开发者友好性。
* 原型需满足明确的性能指标：P99延迟 \< 5ms，吞吐量 \> 200 TPM（可水平扩展）。

### **背景上下文**

现有的点对点RPC模式无法满足分布式交易系统多服务间灵活通信的需求。先前基于ZeroMQ的异步改造尝试存在消息丢失的风险，这在交易系统中是不可接受的。因此，本项目旨在构建一个既能支持多对多拓扑、具备高性能，又能提供可靠消息投递保证（特别是针对异步请求/响应和主备切换场景）的进程间通信组件原型。

### **变更日志**

| 日期 | 版本 | 描述 | 作者 |
| :---- | :---- | :---- | :---- |
| 2025-07-20 | 1.0 | 初始草案创建 | John (PM) |

## **2\. 需求**

### **功能性需求 (Functional Requirements)**

* **FR1: 服务注册与发现**: 任何服务实例都必须能向中央路由组件注册其服务名称、实例ID，以及它正在处理的特定资源（例如，账户ID），并能被系统发现。
* **FR2: 服务组路由**: 对于可以有多个实例的服务组，请求可以被发送到该服务组的“服务名”，并由其中任意一个健康的实例接收并处理。
* **FR3: 目标路由**: 系统必须支持将请求精确地路由到管理特定资源的**唯一服务实例**。
* **FR4: 自动故障转移**: 中央路由组件必须能够通过心跳或健康检查机制实时监控服务实例的存活状态，并在主实例故障后自动将路由切换到其备用实例上。

### **非功能性需求 (Non-Functional Requirements)**

* **NFR1: 精确一次投递保证**: 在任何路由模式下，消息投递都必须保证“精确一次”语义，不能出现消息丢失或重复处理。
* **NFR2: 状态一致性保证**: 在主备切换过程中，必须有机制确保状态的最终一致性。
* **NFR3: 客户端连接透明性**: 客户端库（SDK）应能封装主备切换的复杂性，使该过程对业务调用方无感知。
* **NFR4: 可观测性**: 系统必须提供结构化的JSON日志输出，并暴露核心性能指标以便对接监控系统。
* **NFR5: 可管理性**: 系统必须提供一个基础的管理接口（如CLI），允许操作者查询和管理系统状态。

### **核心工程实践原则 (Core Engineering Principles)**

* 本项目开发将严格遵循用户提供的10项核心原则与工程实践，包括领域驱动设计、契约驱动开发、自动化代码质量保障、分层测试策略、容器化等。这些原则将作为所有故事开发的基本验收标准。

## **3\. 技术假设**

* **客户端技术**: 客户端库必须是Python，以便与现有项目集成。
* **部署环境**: 原型将部署在受信任的内部网络中，因此暂时不考虑服务间认证和通信加密等安全性需求。
* **技术选型**: 整体技术选型需遵循“精简可靠”的原则，避免不必要的复杂性。

## **4\. 史诗 (Epics)**

### **Epic 1: 核心路由与可靠投递**

**目标**: 构建通信系统的基础骨架，实现服务注册发现、两种核心路由模式，并完成“精确一次投递”的核心逻辑。

* **故事 1.1: 项目初始化与工程实践框架搭建**
  * **As a** 开发人员, **I want** 一个使用现代化工具、自动化质量检查和容器化环境初始化的新项目, **so that** 所有未来的开发都能遵循已确立的高质量工程实践。
  * **验收标准**:
    1. 项目使用 uv 和 pyproject.toml 管理依赖。
    2. Black, Ruff, Mypy 已配置并集成到pre-commit hook。
    3. 提供 Dockerfile 和 docker-compose.yaml 用于本地开发。
    4. 初始源代码目录遵循分层结构（domain, application, infrastructure）。
* **故事 1.2: 服务实例的基础注册与发现**
  * **As a** 服务实例, **I want** 能够向中央路由组件注册我的服务名和实例ID, **so that** 系统能够知道我的存在。
  * **验收标准**:
    1. 服务实例启动时能成功注册信息。
    2. 中央组件能存储和管理在线服务实例信息。
    3. 可通过管理接口查询已注册的服务列表。
* **故事 1.3: 实现服务组的轮询路由**
  * **As a** 调用方, **I want** 将请求发送到一个服务“名称”，并让系统自动将它路由给该服务组中一个可用的实例, **so that** 我可以实现对无状态服务的请求负载均衡。
  * **验收标准**:
    1. 发送到服务名的请求被投递到其中一个实例。
    2. 连续请求被分发到不同实例。
    3. 掉线实例会自动从路由池中移除。
* **故事 1.4: 实现基于资源的精确目标路由**
  * **As a** 调用方, **I want** 将一个请求发送给一个特定的“资源”, **so that** 系统能将该请求精确地投递到唯一一个正在处理该资源的实例上。
  * **验收标准**:
    1. 服务实例能注册自己正在处理一个或多个“资源ID”。
    2. 一个“资源ID”在同一时间只能被一个实例注册。
    3. 包含“资源ID”的请求被精确路由到对应的实例。
    4. 若请求的“资源ID”无实例处理，则返回明确错误。
* **故事 1.5: 构建“精确一次投递”的消息处理机制**
  * **As a** 通信系统, **I want** 实现一套结合了消息去重和应答确认的机制, **so that** 我能提供“精确一次”的投递保证。
  * **验收标准**:
    1. 发出的每条请求消息都有全局唯一ID。
    2. 接收方在成功处理业务后必须发送ACK。
    3. 系统在未收到ACK时会进行重试。
    4. 接收方必须是幂等的，能根据消息ID安全地忽略重复消息。

### **Epic 2: 高可用与故障转移**

**目标**: 在核心路由的基础上，增加主/备实例的健康检查、状态同步和自动故障转移机制，实现客户端的无感切换。

* **故事 2.1: 实现服务实例的心跳与健康检查**
  * **As a** 中央路由组件, **I want** 接收所有服务实例的周期性心跳, **so that** 我能准确地发现故障实例。
  * **验收标准**:
    1. 服务实例自动定期发送心跳。
    2. 中央组件根据心跳超时将实例标记为“不健康”。
    3. “不健康”的实例会从路由池中移除。
    4. “主用”实例不健康时触发故障转移。
* **故事 2.2: 支持主/备模式的服务注册**
  * **As a** 服务实例, **I want** 在注册处理特定资源时，能够声明自己的角色是“主用”还是“备用”, **so that** 系统可以建立明确的主备关系。
  * **验收标准**:
    1. 注册接口增加role参数(active/standby)。
    2. 同一资源只能有一个active实例。
    3. 重复注册active角色会被拒绝。
    4. 管理接口能展示主备关系。
* **故事 2.3: 实现自动的主/备切换逻辑**
  * **As a** 中央路由组件, **I want** 在监测到“主用”实例故障后，自动提升一个“备用”实例为新的“主用”, **so that** 服务可以尽快恢复。
  * **验收标准**:
    1. active实例不健康时自动触发故障转移。
    2. 系统从健康的standby实例中选择一个提升为active。
    3. 新的active实例立刻开始接收请求。
    4. 故障转移事件被详细记录在日志中。

### **Epic 3: 可观测性、可管理性与性能验证**

**目标**: 实现结构化日志、性能指标的暴露和管理接口。同时，构建并运行性能测试，验证系统是否满足所有目标。

* **故事 3.1: 集成并实现统一的结构化日志**
  * **As a** 开发/运维人员, **I want** 系统中所有组件都能输出统一的、结构化的（JSON格式）日志, **so that** 我可以方便地进行日志查询和故障排查。
  * **验收标准**:
    1. 集成日志库并配置JSON输出。
    2. 一次请求-响应生命周期的所有日志都包含同一个Trace ID。
    3. 所有关键事件都被记录。
* **故事 3.2: 暴露核心系统性能指标**
  * **As a** 运维人员, **I want** 系统能够通过一个标准的HTTP端点（例如 /metrics）暴露核心性能指标, **so that** 我可以实现对系统健康状况的实时监控。
  * **验收标准**:
    1. 中央路由组件提供 /metrics 端点。
    2. 至少暴露：在线实例数、队列深度、处理延迟、消息总量等指标。
    3. 指标能被Prometheus等工具采集。
* **故事 3.3: 开发基础的管理命令行工具 (CLI)**
  * **As a** 运维人员, **I want** 一个简单的命令行工具来与系统进行交互, **so that** 我可以执行实时的查询和基本管理操作。
  * **验收标准**:
    1. 提供 ipc-cli 脚本。
    2. ipc-cli list-services: 列出所有服务及其状态。
    3. ipc-cli show-route \<resource\_id\>: 查询特定资源的路由。
    4. ipc-cli disconnect \<instance\_id\>: 剔除某个实例。
* **故事 3.4: 构建并执行性能基准测试**
  * **As a** 开发人员, **I want** 一套自动化的性能测试脚本, **so that** 我可以验证系统原型是否达到了预设的性能和可靠性目标。
  * **验收标准**:
    1. 创建性能测试脚本，模拟真实负载。
    2. 测试能覆盖两种路由模式。
    3. 测试报告包含P99延迟和平均吞吐量。
    4. 验证测试结果是否达标（**吞吐量 \> 200 TPM, P99延迟 \< 5ms**）。
    5. 验证测试期间消息丢失率为 **0%**。